# 이진검색트리

자식을 2개까지 가질 수 있는 검색 트리.  

특성
- 각 노드는 키값을 하나씩 갖는다. 각 노드의 키값은 모두 다르다.
- 최상위 레벨에 루트 노드가 있다.
- 각 노드의 키값은 자신의 왼쪽 자식들의 키값보다 크고, 오른쪽 자식들의 키값보다 작다.

## 구현

### TreeNode

```java

public class TreeNode {
    public Comparable key;
    public TreeNode left;
    public TreeNode right;

    public TreeNode(Comparable newKey) {
        key = newKey;
        left = right = null;
    }

    public TreeNode(Comparable newKey, TreeNode leftNode, TreeNode rightNode) {
        key = newKey;
        left = leftNode;
        right = rightNode;
    }
}

```

### IndexInterface<T>

```java

public interface IndexInterface<T> {
    public T search(Comparable x);

    public void insert(Comparable x);

    public void delete(Comparable x);

    public boolean isEmpty();

    public void clear();
}

```

### BinarySearchTree

```java
public class BinarySearchTree implements IndexInterface<TreeNode> {

    private TreeNode root;

    public BinarySearchTree() {
        root = null;
    }

    @Override
    public TreeNode search(Comparable x) {
        return searchItem(root, x);
    }

    private TreeNode searchItem(TreeNode tNode, Comparable searchKey) {
        if (tNode == null) {
            return null;
        } else if (searchKey.compareTo(tNode.key) == 0) {
            return tNode;
        } else if (searchKey.compareTo(tNode.key) < 0) {
            return searchItem(tNode.left, searchKey);
        } else {
            return searchItem(tNode.right, searchKey);
        }
    }

    @Override
    public void insert(Comparable x) {
        root = insertItem(root, x);
    }

    private TreeNode insertItem(TreeNode tNode, Comparable newItem) {
        if (tNode == null) {
            tNode = new TreeNode(newItem);
        } else if (newItem.compareTo(tNode.key) < 0) {
            tNode.left = insertItem(tNode.left, newItem);
        } else {
            tNode.right = insertItem(tNode.right, newItem);
        }

        return tNode;
    }

    @Override
    public void delete(Comparable x) {
        root = deleteItem(root, x);
    }

    // 삭제할 노드 탐색
    private TreeNode deleteItem(TreeNode tNode, Comparable item) {
        if (tNode == null) {
            System.out.println("cannot find delete item");
            return null;
        } else {
            if (item.compareTo(tNode.key) == 0) {
                tNode = deleteNode(tNode);
            } else if (item.compareTo(tNode.key) < 0) {
                tNode.left = deleteItem(tNode.left, item);
            } else {
                tNode.right = deleteItem(tNode.right, item);
            }
            return tNode;
        }
    }

    // 노드 삭제
    private TreeNode deleteNode(TreeNode tNode) {
        // 삭제하려는 노드가 리프 노드일 때
        if (tNode.left == null && tNode.right == null) {
            return null;
        }

        // 삭제하려는 노드가 자식 하나를 가진 노드일 때
        else if (tNode.left == null) {
            return tNode.right;
        } else if (tNode.right == null) {
            return tNode.left;
        }

        // 삭제하려는 노드가 자식 둘을 가진 노드일 때
        else {
            minNodeInfo min = minNode(tNode);
            tNode.key = min.key;
            return tNode;
        }
    }

    // 오른쪽에서 최소값 찾기
    private minNodeInfo minNode(TreeNode tNode) {
        if (tNode.left == null) {
            return new minNodeInfo(tNode.key, tNode.right);
        } else {
            minNodeInfo min = minNode(tNode.left);
            tNode.left = min.child;
            return min;
        }
    }

    private class minNodeInfo {
        private Comparable key;
        private TreeNode child;

        private minNodeInfo(Comparable key, TreeNode child) {
            this.key = key;
            this.child = child;
        }
    }

    @Override
    public boolean isEmpty() {
        return root == null;
    }

    @Override
    public void clear() {
        root = null;
    }

}

```

## 검증

```java

public class App {
    public static void main(String[] args) throws Exception {
        BinarySearchTree tree = new BinarySearchTree();
        tree.insert(10);
        tree.insert(20);
        tree.insert(80);
        tree.insert(90);
        tree.insert(75);
        tree.insert(30);
        tree.insert(77);
        tree.insert(15);
        tree.insert(40);

        Integer del1 = 20;
        tree.delete(del1);
        System.out.println("deleted");
        Integer del2 = 20;
        tree.delete(del2);

    }
}

```
