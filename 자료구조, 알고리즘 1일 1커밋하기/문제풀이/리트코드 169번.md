# Majority Element

## 문제 분석
-    majority element: n/2 이상 나온 요소
-    항상 존재한다고 가정 - 없는 경우 신경 안 써도 됨
-    n: 1 ~ 50000
-    follow up: 시간복잡도 O(n), 공간복잡도 O(1)

## 구현

- 퀵정렬로 정렬한 뒤, 연속된 값을 세어주도록 했다.
- 정렬 이유: 추가적인 공간 할당 없이 개수를 셀 수 있도록 하기 위하여

```java


    public int majorityElement(int[] nums) {
        
        sort(nums, 0, nums.length-1);

        int cnt=0;
        int before=nums[0];

        for(int i=0;i<nums.length;i++){            
            if(nums[i]==before){
                ++cnt;                
                if(cnt>(nums.length/2)){
                    return before;
                }
            }
            else {
                cnt=1;
                before=nums[i];
            }
        }

        return before;
    }

    private static void sort(int[] nums, int start, int end){
        if(start>end) return;

        int pivot=partition(nums, start, end);
        int n=nums.length/2;

        sort(nums, start, pivot-1);
        sort(nums, pivot+1, end);
    }

    private static int partition(int[] nums, int start, int end){
        int mid=(start+end)/2;
        int pivot=nums[mid];
        swap(nums, start, mid);
        int low=start;
        int high=end;

        while(low<high){
            while(nums[high]>pivot) --high;
            while(low<high && nums[low]<=pivot) ++low;

            swap(nums, high, low);
        }

        swap(nums, start, low);
        return low;
    }

    private static void swap(int[] arr, int i, int j){
        int tmp=arr[i];
        arr[i]=arr[j];
        arr[j]=tmp;
    }

```
