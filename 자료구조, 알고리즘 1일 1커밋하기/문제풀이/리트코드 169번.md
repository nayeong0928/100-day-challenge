# Majority Element

## 문제 분석
-    majority element: n/2 이상 나온 요소
-    항상 존재한다고 가정 - 없는 경우 신경 안 써도 됨
-    n: 1 ~ 50000
-    follow up: 시간복잡도 O(n), 공간복잡도 O(1)

## 구현
### 아이디어
    1. 해시에 값-개수 넣어서 n/2개 이상 있으면 리턴: 공간복잡도 제약
    
    2. 같은 값끼리 모으는 방식: start&end
        하나의 원소 추가될 때 지금 값과 같으면 -> end+1자리와 교환, end++
        지금 값과 다르면 -> end 증가 없이 계속 배열 탐색
        최악의 경우(같은 수가 n/2개 나오기 전에 n/2개의 수가 하나씩 있는 경우) : O(n^2)이므로 안 됨
    
    3. 퀵정렬: pivot을 기준으로 pivot보다 작으면 앞, 크면 뒤
        pivot=partition(nums, 0, nums.length-1)  
        pivot이 n/2보다 큰 경우->앞부분에서 majority element 찾기  
        pivot이 n/2보다 작은 경우->뒷부분에서 & majority element 찾기  
        
        partition(int[] nums, int start, int end): pivot의 위치 찾아주는 함수  
            mid=(start+end)/2  
            pivot=nums[mid]  
            swap(nums, start, mid) -> 피봇 제외하고 셀 수 있도록

            while(low<high)
                high: nums[high]가 pivot보다 작거나 같은 동안 계속 --high
                low: nums[high]가 pivot보다 크고 low<high인 동안 계속 ++low
                low와 high 교환
            
            swap(nums, start, low) -> nums[start]에 저장해둔 피봇 자리 찾아주기
            return low;
