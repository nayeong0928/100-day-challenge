# Merge Sorted Array

## 문제분석

- 병합정렬 문제로, 각각의 배열이 정렬되어 있음
- 따로 정렬 작업 없이 두 배열을 비교해서 더 작은 값을 nums1에 넣어주는 방식을 반복하면 됨
- nums1은 m+n 길이이고, n길이만큼 0으로 채워져 있음 : 이 공간을 활용하면 공간복잡도가 줄어들 것 같다
- n길이만큼 0으로 채운 부분을 nums1의 앞으로 보내면 O(m) 만큼의 시간복잡도 사용 : 0 <= m, n <= 200 이기 때문에 최악 상황에서도 괜찮을 것 같다

 ## 구현
 
 - mi: nums1의 인덱스
 - ni: nums2의 인덱스
 - oi: 정렬할 위치, `nums1[mi]`와 `nums2[ni]` 중 더 작은 값을 이 위치에 넣어준다

```java

    public void merge(int[] nums1, int m, int[] nums2, int n) {
        
        for(int i=nums1.length-1;i>=n;i--){
            nums1[i]=nums1[i-n];
        }

        int mi=n;
        int ni=0;
        int oi=0;

        while(mi<nums1.length && ni<n){
            if(nums1[mi]<nums2[ni]){
                nums1[oi]=nums1[mi];
                mi++;
                oi++;
            } else {
                nums1[oi]=nums2[ni];
                ni++;
                oi++;
            }
        }

        if(ni<n){
            System.arraycopy(nums2,ni,nums1,oi,n-ni);
        }
    }

```
