# Min Cost Climbing Stairs

## 문제 분석

- 시작은 인덱스 0 or 1
- 계단을 1개 or 2개 오를 수 있음
- 인덱스가 cost 길이가 되면 꼭대기
- cost 길이는 2 ~ 1000 
- cost 값은 최대 999

### 테스트 케이스

- case 1: [10,15,20]
- case 2: [1,100,1,1,1,100,1,1,100,1]
- (추가) case 3: [1,100,1,1,1,100,1,1,100,999] 
- (추가) case 4: [20,3]

## 구현

- sum 배열 i번째 값: 계단 i에 도착하기까지의 최소비용
- 1,2 걸음만 걸을 수 있기 때문에 sum[i-1], sum[i-2] 값 비교해서 더 작은 것을 cost[i]에 더함
- sum을 cost보다 1 크게 만들어서 맨 마지막에 계단을 다 오른 경우의 최소값이 저장되도록 함 (맨 마지막 계단 밟지 않은 경우 고려)
- 배열을 순회하면서 앞의 2개의 값을 비교/계산하므로 시간복잡도는 O(N)

``` java

    public int minCostClimbingStairs(int[] cost) {
        
        if(cost.length==2){
            return (cost[0]>cost[1])?cost[1]:cost[0];
        }

        int[] sum=Arrays.copyOf(cost, cost.length+1);
        
        for(int i=2; i<sum.length; i++){
            int min=(sum[i-1]<sum[i-2])?sum[i-1]:sum[i-2];
            sum[i]=sum[i]+min;
        }

        return sum[sum.length-1];
        
    }

```

### 테스트케이스 결과

- case 1: [10,15,20] -> 15
- case 2: [1,100,1,1,1,100,1,1,100,1] -> 6
- (추가) case 3: [1,100,1,1,1,100,1,1,100,999]  -> 104
- (추가) case 4: [20,3] -> 3

