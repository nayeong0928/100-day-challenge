# 수 찾기

## 문제 분석

- N개의 정수 중 X라는 수가 존재하는지 확인
- 범위
  - 1 ≤ N ≤ 100,000
  - 1 ≤ M ≤ 100,000
  - 이중 for문으로 풀었을 때 최악의 경우 10억이므로 이진탐색 사용
    
## 풀이

- Arrays.sort()의 시간복잡도가 O(nlog(n)) 이기 때문에 직접 퀵소트 구현보다는 정렬 후 이진탐색하도록 한다


``` java

import java.util.Arrays;
import java.util.Scanner;

public class sol1920 {

    public static void main(String[] args) {

        // System.out.println(solve(new int[] { 4, 1, 5, 2, 3 }, new int[] { 1, 3, 7, 9,
        // 5 }));
        // 배열 길이가 1인 경우
        // System.out.println(solve(new int[] { 4 }, new int[] { 5 }));

        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] arr = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = sc.nextInt();
        }
        int M = sc.nextInt();
        int[] num = new int[M];
        for (int i = 0; i < M; i++) {
            num[i] = sc.nextInt();
        }

        System.out.println(solve(arr, num));
    }

    private static String solve(int[] arr, int[] nums) {

        Arrays.sort(arr);
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < nums.length; i++) {
            sb.append(exist(arr, nums[i]) ? 1 : 0);
            sb.append("\n");
        }

        return sb.toString();
    }

    private static boolean exist(int[] arr, int N) {
        int start = 0;
        int end = arr.length - 1;

        while (start <= end && start < arr.length && end >= 0) {
            int mid = (start + end) / 2;
            if (arr[mid] == N)
                return true;
            else if (arr[mid] > N) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        return false;
    }
}


```
