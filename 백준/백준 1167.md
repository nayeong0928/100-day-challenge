# 트리의 지름 

## 문제분석

- 트리의 지름: 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것.
- 트리이기 때문에 모든 정점이 사이클 없이 연결되어 있음.
- 주어진 정점의 거리는 1000 이하의 자연수.
    - 트리의 지름은 모든 정점을 거친다.
    - 한 정점에서 다른 정점으로 가는 경로는 유일하다.

## 풀이

- 정점의 범위가 2 ≤ V ≤ 100,000 이기 때문에 그래프를 1차원 그래프와 연결리스트로 나타냈다.

### BFS(1)와 BFS(max)

- V는 2개 이상이기 때문에 임의의 정점 1은 무조건 존재한다.
- 한 정점에서 다른 정점으로 가는 경로는 유일하기 때문에 최대 경로는 임의의 정점의 최대경로와 반드시 겹친다.
- 따라서 우선 임의의 정점 1을 기준으로 각 정점의 최대거리를 distance에 저장한다.
- 1을 기준으로 최대 경로를 가지는 max값을 기준으로 다시 탐색한다. (1보다 멀리 있는 정점이 있을 수 있기 때문에)

### 전체 코드

```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

public class sol1167_2 {

    static int V;
    static List<Edge>[] tree;
    static boolean[] visited;
    static int[] distance;

    public static void main(String[] args) throws NumberFormatException, IOException {

        // 입력
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        V = Integer.parseInt(br.readLine());
        tree = new ArrayList[V + 1];
        visited = new boolean[V + 1];

        for (int i = 1; i <= V; i++) {
            tree[i] = new ArrayList<>();
        }

        StringTokenizer st;

        for (int i = 0; i < V; i++) {
            String line = br.readLine();
            st = new StringTokenizer(line);
            int from = Integer.parseInt(st.nextToken(" "));

            while (true) {
                int to = Integer.parseInt(st.nextToken(" "));
                if (to == -1)
                    break;
                int dist = Integer.parseInt(st.nextToken(" "));
                Edge edge = new Edge(to, dist);
                tree[from].add(edge);
            }
        }
        // 입력 끝
        distance = new int[V + 1];
        BFS(1);
        int max = 1;
        for (int i = 1; i <= V; i++) {
            if (distance[max] < distance[i]) {
                max = i;
            }
        }
        distance = new int[V + 1];
        BFS(max);
        Arrays.sort(distance);
        System.out.println(distance[V]);

    }

    static void BFS(int start) {

        Queue<Integer> queue = new LinkedList<>();
        visited = new boolean[V + 1];
        visited[start] = true;
        queue.add(start);

        while (!queue.isEmpty()) {
            int now = queue.poll();

            for (Edge e : tree[now]) {
                if (!visited[e.node]) {
                    visited[e.node] = true;
                    queue.add(e.node);
                    distance[e.node] = distance[now] + e.dist;
                }
            }
        }

    }

    static class Edge {
        int node;
        int dist;

        public Edge(int n, int d) {
            this.node = n;
            this.dist = d;
        }
    }
}


```
